<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Conjugation Sprint — Latvian B1</title>
<style>
  :root { --gap: 14px; }
  body{font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Liberation Sans";}
  .app{max-width:760px;margin:4rem auto;padding:0 1rem}
  h1{font-size:1.6rem;margin:0 0 .25rem}
  .sub{opacity:.7;margin-bottom:1.2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin:0 0 var(--gap)}
  .q{font-size:1.3rem;margin-bottom:.4rem}
  .meta{font-size:.95rem;opacity:.8;margin-bottom:.75rem}
  .btns{display:grid;gap:.5rem}
  button{padding:.7rem 1rem;border:1px solid #ccc;border-radius:10px;background:#fff;cursor:pointer}
  button[disabled]{opacity:.7;cursor:default}
  .ok{border-color:#7cbf7c}
  .bad{border-color:#e08974}
  .row{display:flex;gap:var(--gap);align-items:center;flex-wrap:wrap}
  .pill{border:1px solid #ddd;border-radius:999px;padding:.25rem .6rem;font-size:.9rem}
  .stats{display:grid;grid-template-columns:repeat(6,1fr);gap:6px;font-size:.85rem;margin-top:var(--gap)}
  .stats div{border:1px solid #eee;border-radius:6px;padding:.35rem .45rem;text-align:center}
  .muted{opacity:.65}
  .footer{margin-top:1.2rem;display:flex;gap:var(--gap);align-items:center;flex-wrap:wrap}
</style>

<div class="app">
  <h1>Conjugation Sprint</h1>
  <div class="sub">Focus: verbs with full paradigms (present • past • future). Data from your <code>words.json</code>.</div>

  <div class="card" id="game">
    <div class="q" id="qtext">Loading…</div>
    <div class="meta" id="meta"></div>
    <div class="btns" id="choices"></div>
    <div class="footer">
      <span class="pill" id="score">score 0</span>
      <span class="pill" id="streak">streak 0</span>
      <span class="pill" id="round">round 0/20</span>
      <button id="skip">Skip</button>
      <button id="again">Play again</button>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="pill">es</div><div class="pill">tu</div><div class="pill">viņš/viņa</div>
      <div class="pill">mēs</div><div class="pill">jūs</div><div class="pill">viņi/viņas</div>
    </div>
    <div class="stats" id="perstats">
      <div>0%</div><div>0%</div><div>0%</div><div>0%</div><div>0%</div><div>0%</div>
    </div>
    <div class="muted" style="margin-top:.5rem">Tip: Watch your endings—<i>–u, –i, –a; –am, –at</i> in the past; and the future’s <i>–š</i> spine.</div>
  </div>
</div>

<script>
const PRONS = ["es","tu","viņš/viņa","mēs","jūs","viņi/viņas"];
const IDX = { "es":"1s", "tu":"2s", "viņš/viņa":"3s", "mēs":"1p", "jūs":"2p", "viņi/viņas":"3p" };
const TENSES = ["present","past","future"];
let bank=[], score=0, streak=0, round=0, maxRounds=20, lock=false;
let perRight = { "1s":0,"2s":0,"3s":0,"1p":0,"2p":0,"3p":0 }, perSeen = { "1s":0,"2s":0,"3s":0,"1p":0,"2p":0,"3p":0 };

const qEl = id("qtext"), mEl = id("meta"), cEl = id("choices");
const scoreEl = id("score"), streakEl = id("streak"), roundEl = id("round");
const perStatsEl = id("perstats"); id("again").onclick = reset; id("skip").onclick = ()=>check(null);

fetch("../data/words.json").then(r=>r.json()).then(data=>{
  bank = data.filter(v => v.conj && v.conj.present && v.conj.past && v.conj.future);
  if(bank.length===0){ qEl.textContent="No verbs with conjugations found."; return; }
  reset();
});

function reset(){
  score=0; streak=0; round=0;
  for(const k in perRight){ perRight[k]=0; perSeen[k]=0; }
  next();
}

function id(x){ return document.getElementById(x); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]= [a[j],a[i]]; } return a; }

let current=null;
function next(){
  lock=false;
  round++;
  roundEl.textContent=`round ${round}/${maxRounds}`;
  if(round>maxRounds){ finish(); return; }

  const v = pick(bank);
  const tense = pick(TENSES);
  const pron = pick(PRONS);
  const slot = IDX[pron];
  const correct = v.conj[tense][slot];

  // Build distractors smartly
  const d1 = pick(bank).conj[tense][slot];                         // same person, different verb
  const d2 = v.conj[tense][pick(Object.values(IDX))];               // same verb, different person
  const d3 = v.conj[pick(TENSES.filter(t=>t!==tense))][slot];       // same person, different tense
  let options = [correct, d1, d2, d3].filter((x,i,arr)=>arr.indexOf(x)===i);
  while(options.length<4){ options.push(pick(bank).conj[tense][slot]); options=[...new Set(options)]; }
  shuffle(options);

  current = { v, tense, pron, slot, correct };
  qEl.textContent = `${v.lv} — ${pron} (${tense})`;
  mEl.textContent = v.eng || "";

  cEl.innerHTML="";
  options.forEach(opt=>{
    const b=document.createElement("button"); b.textContent = opt;
    b.onclick = ()=>check(opt, b);
    cEl.appendChild(b);
  });
  updateHUD();
}

function check(ans, btn){
  if(lock) return; lock=true;
  perSeen[current.slot]++;

  const buttons = [...cEl.querySelectorAll("button")];
  buttons.forEach(b=>b.disabled=true);

  if(ans===current.correct){
    score+=2; streak++;
    if(btn){ btn.classList.add("ok"); }
  }else{
    streak=0;
    if(btn){ btn.classList.add("bad"); }
  }
  // highlight correct answer
  const good = buttons.find(b=>b.textContent===current.correct);
  if(good) good.classList.add("ok");

  if(ans===current.correct) perRight[current.slot]++;

  updateHUD();
  setTimeout(()=> (round<maxRounds ? next() : finish()), 700);
}

function updateHUD(){
  scoreEl.textContent = `score ${score}`;
  streakEl.textContent = `streak ${streak}`;
  const rows = PRONS.map(p=>{
    const k=IDX[p];
    const seen=perSeen[k]||0, right=perRight[k]||0;
    const pct = seen? Math.round(100*right/seen):0;
    return pct;
  });
  perStatsEl.innerHTML = rows.map(v=>`<div>${v}%</div>`).join("");
}

function finish(){
  qEl.textContent = "Sprint complete!";
  mEl.textContent = "Replay to reinforce weak pronouns. Aim for 90%+ across all six slots.";
  cEl.innerHTML="";
}
</script>