<!doctype html>
<html lang="lv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="format-detection" content="telephone=no" />
<title>B1 LV‚ÜíEN: Match Rush + Prefix Forge</title>
<style>
  /* ===========================
     Global look & feel - RESPONSIVE
     =========================== */
  html,body{margin:0;padding:0;background:#0e0f13;color:#e9eef5;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow-x:hidden;}
  #wrap{max-width:980px;margin:0 auto;padding:12px;width:100%;box-sizing:border-box;}
  h1{font-weight:800;margin:8px 0 4px;font-size:clamp(18px,4vw,24px);}  
  #ui{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px;justify-content:center;}
  button{border:0;padding:8px 12px;border-radius:10px;background:#2a2f3a;color:#e9eef5;cursor:pointer;font-weight:700;font-size:clamp(12px,2.5vw,14px);touch-action:manipulation;min-height:44px;-webkit-user-select:none;user-select:none;}
  button:hover{filter:brightness(1.1)}
  button:active{transform:scale(0.98);}  
  button[disabled]{opacity:.4;cursor:not-allowed}
  .pill{background:#1c7ed6}
  .ghost{background:#3b3f4a}
  .ok{background:#2f9e44}
  .outline{background:transparent;border:2px solid #3b3f4a}
  .small{padding:6px 10px;font-size:clamp(10px,2vw,12px);border-radius:999px;min-height:36px;}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#111;border-radius:6px;padding:2px 6px}
  #canvas{display:block;width:100%;height:auto;border-radius:12px;background:linear-gradient(180deg,#12131a 0%,#12151c 100%);box-shadow:0 6px 30px rgba(0,0,0,.35);max-width:100%;transition:opacity 0.3s ease;}
  #canvas.loading{opacity:0.7;}
  #legend{font-size:clamp(11px,2.5vw,13px);opacity:.8;margin-top:6px;text-align:center;}
  a{color:#91c9ff}

  /* ===== New: top header badge ===== */
  #header{display:flex;align-items:center;justify-content:flex-start;margin:2px 0 6px;}
  .week-badge{display:inline-block;background:#1c7ed6;color:#fff;font-weight:800;padding:6px 12px;border-radius:999px;font-size:clamp(12px,2.5vw,14px);letter-spacing:.3px;box-shadow:0 2px 10px rgba(0,0,0,.25);}  

  /* Responsive canvas container */
  .canvas-container{position:relative;width:100%;max-width:980px;margin:0 auto;}

  /* Loading overlay */
  .loading-overlay{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#9fb3ff;font-size:14px;pointer-events:none;opacity:0;transition:opacity 0.3s ease;}
  .loading-overlay.visible{opacity:1;}

  /* Mobile-specific styles */
  @media (max-width: 768px) {
    #wrap{padding:8px;}
    h1{text-align:center;font-size:20px;}
    #header{justify-content:center;}
    #ui{gap:6px;justify-content:center;}
    button{padding:12px 10px;font-size:13px;min-width:60px;min-height:48px;} /* Larger touch targets */
    .small{padding:10px 8px;font-size:12px;min-height:44px;}
    #status{order:10;width:100%;text-align:center;margin-top:8px;margin-left:0!important;}
    /* Stack buttons on very small screens */
    #ui{flex-direction:row;align-items:center;}
  }
  
  @media (max-width: 480px) {
    #wrap{padding:6px;}
    h1{font-size:18px;}
    button{padding:10px 8px;font-size:12px;min-width:55px;min-height:46px;}
    #ui{gap:4px;flex-wrap:wrap;}
    /* Smaller buttons for tiny screens but still touch-friendly */
    .small{min-width:50px;padding:8px 6px;min-height:42px;}
  }
  
  @media (max-width: 360px) {
    button{padding:8px 6px;font-size:11px;min-width:50px;}
    .small{min-width:45px;padding:6px 4px;}
  }

  /* iOS Safari specific fixes */
  @supports (-webkit-touch-callout: none) {
    /* iOS Safari viewport fix */
    body {
      height: -webkit-fill-available;
    }
    
    /* Improve touch responsiveness on iOS */
    button, canvas {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    /* Fix iOS Safari bounce scrolling */
    body {
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    #wrap {
      height: 100vh;
      height: -webkit-fill-available;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
  }

  /* High DPI displays (Retina, etc.) */
  @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    #canvas {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
  }

  /* Landscape orientation adjustments for mobile */
  @media (max-width: 768px) and (orientation: landscape) {
    h1 {
      font-size: 16px;
      margin: 4px 0 2px;
    }
    
    #ui {
      margin: 4px 0 6px;
    }
    
    button {
      padding: 8px 6px;
      min-height: 36px;
    }
    
    .small {
      padding: 6px 4px;
      min-height: 32px;
    }
  }

  /* Windows touch device optimizations */
  @media (pointer: coarse) {
    button {
      min-height: 44px; /* Windows touch guidelines */
    }
    
    .small {
      min-height: 36px;
    }
  }
</style>
</head>
<body>
<div id="wrap">
  <!-- New header badge -->
  <div id="header"><span class="week-badge">Week 1</span></div>

  <h1>LV‚ÜíEN VƒÅrdu Spƒìles (B1)</h1>
  <div id="ui">
    <button id="mode-match" class="pill">‚ñ∂ Match Rush</button>
    <button id="mode-forge" class="pill">‚ñ∂ Prefix Forge</button>
    <button id="btn-practice" class="ghost">Practice</button>
    <button id="btn-challenge" class="ghost">Challenge</button>
    <button id="btn-prev" class="outline small">‚ü®</button>
    <button id="btn-next" class="outline small">‚ü©</button>
    <button id="btn-deck-size" class="outline small" title="Toggle deck size">üìè</button>
    <button id="btn-export" class="ok">Export Results (CSV)</button>
    <button id="btn-help" class="ghost">Help</button>
    <span id="status" style="margin-left:auto;font-weight:700;"></span>
  </div>

  <!-- All interactive UI is drawn on this canvas via 2D context -->
  <div class="canvas-container">
    <canvas id="canvas" width="980" height="560"></canvas>
    <div class="loading-overlay" id="loading">Loading...</div>
  </div>
  <div id="legend">
    <b>Controls:</b> Mouse clicks. ‚Äî <span class="kbd">H</span> help, <span class="kbd">R</span> restart round, <span class="kbd">1</span> Match, <span class="kbd">2</span> Forge, <span class="kbd">D</span> deck size. <br/>
    üìè = Fit screen (no scroll), üìú = Full deck (scroll if needed). LV‚ÜíEN only.
  </div>
</div>

<script>
/****************************************************
 * B1 LV‚ÜíEN Canvas Game
 * Modes:
 *  - MATCH RUSH (pair LV‚ÜíEN)
 *  - PREFIX FORGE (add the correct prefix based on an EN clue)
 *
 * Architecture notes (important for future edits):
 *  - Everything is rendered to a single <canvas> (no DOM list items).
 *  - Clickable areas are tracked manually in an array (simple AABB hit-test).
 *  - A deterministic-ish RNG (mulberry32) makes shuffles stable per session.
 *  - Results live in-memory and can be exported to CSV.
 *  - NEW: Match Rush now supports VERTICAL SCROLL inside the canvas, with
 *         mouse wheel + keyboard (‚Üë/‚Üì, PgUp/PgDn, Home/End) + a visual bar.
 ****************************************************/

/* =====================
   DATA: vocabulary & prefix hints (LV‚ÜíEN)
   ===================== */
const DATA = {
  units: [
    {
      name: "Mainƒ´t / Mainƒ´ties ƒ£imene",
      entries: [
        {lv:"mainƒ´t", en:"to change (something)", tags:["base"]},
        {lv:"mainƒ´ties", en:"to change (oneself)/change state", tags:["reflexive"]},
        {lv:"izmainƒ´t", en:"to alter; to change completely", tags:["prefix:iz"]},
        {lv:"pƒÅrmainƒ´t", en:"to transform; change over", tags:["prefix:pƒÅr"]},
        {lv:"nomainƒ´t", en:"to replace; change out", tags:["prefix:no"]},
        {lv:"samainƒ´t", en:"to swap; to exchange", tags:["prefix:sa"]},
        {lv:"apmainƒ´t", en:"to exchange; to switch", tags:["prefix:ap"]}
      ]
    },
    {
      name: "Braukt ar priedƒìkƒºiem",
      entries: [
        {lv:"braukt", en:"to go (by transport)", tags:["base"]},
        {lv:"atbraukt", en:"to arrive (come)", tags:["prefix:at"]},
        {lv:"aizbraukt", en:"to leave, go away", tags:["prefix:aiz"]},
        {lv:"iebraukt", en:"to enter (drive into)", tags:["prefix:ie"]},
        {lv:"izbraukt", en:"to go out (drive out)", tags:["prefix:iz"]},
        {lv:"piebraukt", en:"to drive up to", tags:["prefix:pie"]},
        {lv:"apbraukt", en:"to drive around", tags:["prefix:ap"]},
        {lv:"pƒÅrbraukt", en:"to drive over / across", tags:["prefix:pƒÅr"]},
        {lv:"nobraukt", en:"to drive down / run over", tags:["prefix:no"]},
        {lv:"uzbraukt", en:"to drive up (onto)", tags:["prefix:uz"]},
        {lv:"sabraukt", en:"to gather (arrive by vehicles)", tags:["prefix:sa"]}
      ]
    },
    {
      name: "Iet ar priedƒìkƒºiem",
      entries: [
        {lv:"iet", en:"to go (on foot)", tags:["base"]},
        {lv:"ieiet", en:"to go in, enter", tags:["prefix:ie"]},
        {lv:"iziet", en:"to go out, exit", tags:["prefix:iz"]},
        {lv:"aiziet", en:"to leave, go away", tags:["prefix:aiz"]},
        {lv:"atiet", en:"to depart (train, bus)", tags:["prefix:at"]},
        {lv:"pieiet", en:"to approach, go up to", tags:["prefix:pie"]},
        {lv:"pƒÅriet", en:"to cross, to switch", tags:["prefix:pƒÅr"]},
        {lv:"apiet", en:"to go around", tags:["prefix:ap"]},
        {lv:"noiet", en:"to go down; walk distance", tags:["prefix:no"]},
        {lv:"saiet", en:"to gather together", tags:["prefix:sa"]},
        {lv:"paiet", en:"to pass (time), go by", tags:["prefix:pa"]}
      ]
    },
    {
      name: "NƒÅkt ar priedƒìkƒºiem",
      entries: [
        {lv:"nƒÅkt", en:"to come (on foot)", tags:["base"]},
        {lv:"ienƒÅkt", en:"to come in", tags:["prefix:ie"]},
        {lv:"iznƒÅkt", en:"to come out", tags:["prefix:iz"]},
        {lv:"atnƒÅkt", en:"to arrive, come here", tags:["prefix:at"]},
        {lv:"aiznƒÅkt", en:"to come from afar", tags:["prefix:aiz"]},
        {lv:"pienƒÅkt", en:"to approach; be due", tags:["prefix:pie"]},
        {lv:"sanƒÅkt", en:"to gather; to turn out", tags:["prefix:sa"]},
        {lv:"uznƒÅkt", en:"to come up (weather, emotions)", tags:["prefix:uz"]},
        {lv:"nonƒÅkt", en:"to end up, to arrive at", tags:["prefix:no"]}
      ]
    },
    {
      name: "KƒÅpt ar priedƒìkƒºiem",
      entries: [
        {lv:"kƒÅpt", en:"to climb, step", tags:["base"]},
        {lv:"iekƒÅpt", en:"to get in (vehicle)", tags:["prefix:ie"]},
        {lv:"izkƒÅpt", en:"to get out/off", tags:["prefix:iz"]},
        {lv:"uzkƒÅpt", en:"to climb up", tags:["prefix:uz"]},
        {lv:"nokƒÅpt", en:"to climb down", tags:["prefix:no"]},
        {lv:"pƒÅrkƒÅpt", en:"to step over; to violate", tags:["prefix:pƒÅr"]}
      ]
    },
    {
      name: "Lidot ar priedƒìkƒºiem",
      entries: [
        {lv:"lidot", en:"to fly", tags:["base"]},
        {lv:"ielidot", en:"to fly in (arrive)", tags:["prefix:ie"]},
        {lv:"izlidot", en:"to fly out (depart)", tags:["prefix:iz"]},
        {lv:"atlidot", en:"to fly back", tags:["prefix:at"]},
        {lv:"aizlidot", en:"to fly away", tags:["prefix:aiz"]},
        {lv:"pƒÅrlidot", en:"to fly over", tags:["prefix:pƒÅr"]},
        {lv:"aplidot", en:"to fly around", tags:["prefix:ap"]}
      ]
    },
    {
      name: "Nest ar priedƒìkƒºiem",
      entries: [
        {lv:"nest", en:"to carry (by hand)", tags:["base"]},
        {lv:"ienest", en:"to carry in", tags:["prefix:ie"]},
        {lv:"iznest", en:"to carry out", tags:["prefix:iz"]},
        {lv:"aiznest", en:"to take away", tags:["prefix:aiz"]},
        {lv:"atnest", en:"to bring (here)", tags:["prefix:at"]},
        {lv:"pienest", en:"to bring to; serve", tags:["prefix:pie"]},
        {lv:"pƒÅrnest", en:"to carry over / move", tags:["prefix:pƒÅr"]},
        {lv:"uznest", en:"to carry up", tags:["prefix:uz"]},
        {lv:"nonest", en:"to carry down", tags:["prefix:no"]},
        {lv:"sanest", en:"to bring together (collect)", tags:["prefix:sa"]}
      ]
    },
    {
      name: "Refleksƒ´vie un dzƒ´ves notikumi",
      entries: [
        {lv:"mainƒ´ties", en:"to change oneself, change state", tags:["reflexive"]},
        {lv:"pƒÅrcelties", en:"to move, relocate", tags:["reflexive"]},
        {lv:"atgriezties", en:"to return", tags:["reflexive"]},
        {lv:"ciemoties", en:"to visit, be a guest", tags:["reflexive"]},
        {lv:"viesoties", en:"to visit, be a guest", tags:["reflexive"]},
        {lv:"precƒìties", en:"to marry", tags:["reflexive"]},
        {lv:"apprecƒìties", en:"to get married", tags:["reflexive"]},
        {lv:"piedzimt", en:"to be born"},
        {lv:"celties", en:"to get up", tags:["reflexive"]},
        {lv:"satikties", en:"to meet (each other)", tags:["reflexive"]},
        {lv:"iemƒÅcƒ´ties", en:"to master, learn", tags:["reflexive"]}
      ]
    },
    {
      name: "B1 palƒ´gdarbƒ´bas vƒÅrdi",
      entries: [
        {lv:"apg≈´t", en:"to learn, acquire"},
        {lv:"ieg≈´t", en:"to obtain, gain"},
        {lv:"kƒº≈´t", en:"to become"},
        {lv:"tikt galƒÅ", en:"to manage, cope"},
        {lv:"satikt", en:"to meet (someone)"},
        {lv:"notikt", en:"to happen"},
        {lv:"pietikt", en:"to be enough"},
        {lv:"paveikt", en:"to accomplish"},
        {lv:"pabeigt", en:"to finish"}
      ]
    }
  ],
  // Short mnemonic notes for each prefix (shown as hints in Forge)
  notes: {
    "prefix:iz": "iz- ‚Üí ƒÅrƒÅ/rezultƒÅts; completion/outward.",
    "prefix:pƒÅr": "pƒÅr- ‚Üí pƒÅri/over; across; redo; sometimes 'too much'.",
    "prefix:no": "no- ‚Üí prom/away; removal; replacement.",
    "prefix:sa": "sa- ‚Üí kopƒÅ/together; gathering; sometimes 'a bit'.",
    "prefix:ap": "ap- ‚Üí ap/around; surround; exchange.",
    "prefix:at": "at- ‚Üí atpakaƒº/back; towards.",
    "prefix:aiz": "aiz- ‚Üí prom/away; behind; to a limit.",
    "prefix:ie": "ie- ‚Üí iek≈°ƒÅ/in; entering.",
    "prefix:pie": "pie- ‚Üí pie/at, towards.",
    "prefix:uz": "uz- ‚Üí uz/on, up; direction upward.",
    "prefix:pa": "pa- ‚Üí pa/along; a little; passing by; time passes."
  },
  // Prefix Forge deck: base + correct prefix + English clue
  forge: [
    {base:"mainƒ´t", correct:"iz", en:"to alter; change completely (result)"},
    {base:"mainƒ´t", correct:"pƒÅr", en:"to transform; change over"},
    {base:"mainƒ´t", correct:"no", en:"to replace (change out)"},
    {base:"mainƒ´t", correct:"sa", en:"to swap/exchange (together)"},
    {base:"mainƒ´t", correct:"ap", en:"to exchange/switch (around)"},
    
    {base:"braukt", correct:"ie", en:"to drive in/enter"},
    {base:"braukt", correct:"iz", en:"to drive out; leave"},
    {base:"braukt", correct:"pie", en:"to drive up to"},
    {base:"braukt", correct:"pƒÅr", en:"to drive over/across"},
    {base:"braukt", correct:"ap", en:"to drive around"},
    {base:"braukt", correct:"uz", en:"to drive up (onto)"},
    {base:"braukt", correct:"no", en:"to drive down/off"},
    {base:"braukt", correct:"at", en:"to arrive; come"},
    {base:"braukt", correct:"aiz", en:"to leave; go away"},
    {base:"braukt", correct:"sa", en:"to gather (arrive by vehicles)"},

    {base:"iet", correct:"ie", en:"to go in, enter"},
    {base:"iet", correct:"iz", en:"to go out, exit"},
    {base:"iet", correct:"aiz", en:"to leave, go away"},
    {base:"iet", correct:"at", en:"to depart (train, bus)"},
    {base:"iet", correct:"pie", en:"to approach, go up to"},
    {base:"iet", correct:"pƒÅr", en:"to cross, to switch"},
    {base:"iet", correct:"ap", en:"to go around"},
    {base:"iet", correct:"no", en:"to go down; walk distance"},
    {base:"iet", correct:"sa", en:"to gather together"},
    {base:"iet", correct:"pa", en:"to pass (time), go by"},

    {base:"nƒÅkt", correct:"ie", en:"to come in"},
    {base:"nƒÅkt", correct:"iz", en:"to come out"},
    {base:"nƒÅkt", correct:"at", en:"to arrive, come here"},
    {base:"nƒÅkt", correct:"aiz", en:"to come from afar"},
    {base:"nƒÅkt", correct:"pie", en:"to approach; be due"},
    {base:"nƒÅkt", correct:"sa", en:"to gather; to turn out"},
    {base:"nƒÅkt", correct:"uz", en:"to come up (weather, emotions)"},
    {base:"nƒÅkt", correct:"no", en:"to end up, to arrive at"},

    {base:"kƒÅpt", correct:"ie", en:"to get in (vehicle)"},
    {base:"kƒÅpt", correct:"iz", en:"to get out/off"},
    {base:"kƒÅpt", correct:"uz", en:"to climb up"},
    {base:"kƒÅpt", correct:"no", en:"to climb down"},
    {base:"kƒÅpt", correct:"pƒÅr", en:"to step over; to violate"},

    {base:"lidot", correct:"ie", en:"to fly in (arrive)"},
    {base:"lidot", correct:"iz", en:"to fly out (depart)"},
    {base:"lidot", correct:"at", en:"to fly back"},
    {base:"lidot", correct:"aiz", en:"to fly away"},
    {base:"lidot", correct:"pƒÅr", en:"to fly over"},
    {base:"lidot", correct:"ap", en:"to fly around"},

    {base:"nest", correct:"ie", en:"to carry in"},
    {base:"nest", correct:"iz", en:"to carry out"},
    {base:"nest", correct:"aiz", en:"to take away"},
    {base:"nest", correct:"at", en:"to bring (here)"},
    {base:"nest", correct:"pie", en:"to bring to; serve"},
    {base:"nest", correct:"pƒÅr", en:"to carry over / move"},
    {base:"nest", correct:"uz", en:"to carry up"},
    {base:"nest", correct:"no", en:"to carry down"},
    {base:"nest", correct:"sa", en:"to bring together (collect)"}
  ]
};

/* =====================
   GLOBAL STATE & helpers
   ===================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// RESPONSIVE CANVAS SCALING
let scale = 1;
let canvasOffsetX = 0;
let canvasOffsetY = 0;

function updateCanvasScale() {
  const rect = canvas.getBoundingClientRect();
  const containerWidth = canvas.parentElement.offsetWidth;
  
  // Calculate scale based on container width vs canvas native width
  scale = Math.min(1, containerWidth / 980);
  
  // Update canvas display size while keeping internal resolution
  const displayWidth = 980 * scale;
  const displayHeight = 560 * scale;
  
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  
  // Handle high DPI displays
  const dpr = window.devicePixelRatio || 1;
  if (dpr > 1 && scale < 1) {
    // For high DPI mobile devices, use device pixel ratio for crisp rendering
    const scaledDpr = Math.min(dpr, 2); // Cap at 2x to avoid too much memory usage
    canvas.width = 980 * scaledDpr;
    canvas.height = 560 * scaledDpr;
    ctx.scale(scaledDpr, scaledDpr);
    
    // Update constants used in drawing
    W = 980; // Keep logical coordinates the same
    H = 560;
  }
  
  // Store offsets for coordinate conversion
  const newRect = canvas.getBoundingClientRect();
  canvasOffsetX = newRect.left;
  canvasOffsetY = newRect.top;
}

// Convert screen coordinates to canvas coordinates
function getCanvasCoordinates(clientX, clientY) {
  return {
    x: (clientX - canvasOffsetX) / scale,
    y: (clientY - canvasOffsetY) / scale
  };
}

// Initialize canvas scaling
window.addEventListener('resize', updateCanvasScale);
window.addEventListener('load', updateCanvasScale);
updateCanvasScale();

const MODES = { MATCH:'MATCH', FORGE:'FORGE' };
let mode = MODES.MATCH;                  // current game mode
let difficulty = 'practice';             // 'practice' | 'challenge'
let deckSizeMode = 'auto';              // 'auto' (fit screen) | 'full' (all items, scroll)
let roundIndex = 0;                      // advances each round
let rng = mulberry32(Date.now() >>> 0);  // seeded rng for shuffle

let matchState = null; // state object for MATCH mode
let forgeState = null; // state object for FORGE mode

let results = []; // history of rounds; exported to CSV

// Minimal help popup text (LV for the learners, UI text kept concise)
let showHelp = false;
const HELP_TEXT = [
  "‚ñ∂ MATCH RUSH ‚Äî Klik≈°ƒ∑ini pƒÅri: vispirms LV vƒÅrds, tad tƒÅ EN nozƒ´me.",
  "Kƒº≈´das praksƒì rƒÅda ƒ´su skaidrojumu (piem., -ties = refleksƒ´vs).",
  "Challenge re≈æƒ´mƒÅ ir taimeris un sirdis.",
  "",
  "üìè Deck Size ‚Äî PƒÅrslƒìdz starp 'fit screen' (bez ritinƒÅ≈°anas)",
  "un 'full deck' (ar ritinƒÅ≈°anu, vairƒÅk vƒÅrdu).",
  "",
  "‚ñ∂ PREFIX FORGE ‚Äî Pievieno pareizo priedƒìkli pie verbu saknes",
  "(piem., __mainƒ´t ‚Üí izmainƒ´t) pƒìc dotƒÅs EN nozƒ´mes.",
  "",
  "ƒ™sceƒºi: [1] Match, [2] Forge, [H] help, [R] restart, [D] deck size."
].join("\n");

/* ---------- Utility: RNG & small helpers ---------- */
function mulberry32(a){
  // Tiny deterministic RNG; good enough for UI shuffles
  return function(){
    a|=0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a>>>15, 1 | a);
    t = t + Math.imul(t ^ t>>>7, 61 | t) ^ t;
    return ((t ^ t>>>14) >>> 0) / 4294967296;
  }
}
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(rng()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }
function choice(arr){ return arr[(rng()*arr.length)|0]; }
function now(){ return performance.now(); }

/* ---------- Canvas layout constants ---------- */
let W = canvas.width, H = canvas.height;
function clear(){ ctx.clearRect(0,0,W,H); }

/* ---------- Drawing primitives (rounded rect, text, badge) ---------- */
function roundedRect(x,y,w,h,r,fillStyle,border){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fillStyle){ ctx.fillStyle=fillStyle; ctx.fill(); }
  if(border){ ctx.strokeStyle=border; ctx.lineWidth=2; ctx.stroke(); }
}
function drawText(txt,x,y,opts={}){
  ctx.textAlign = opts.align||'left';
  ctx.textBaseline = opts.base||'alphabetic';
  
  // Scale font size for mobile readability
  const baseFontSize = parseInt(opts.font) || 16;
  const isMobile = scale < 0.7;
  const minSize = isMobile ? 11 : 12;
  const scaleFactor = isMobile ? 1.1 : Math.min(1, scale + 0.3);
  const scaledSize = Math.max(minSize, baseFontSize * scaleFactor);
  
  const fontFamily = opts.font ? opts.font.replace(/\d+px/, scaledSize + 'px') : `${scaledSize}px system-ui`;
  
  ctx.font = fontFamily;
  ctx.fillStyle = opts.color||'#e9eef5';
  
  // Better text rendering for high DPI
  ctx.textRenderingOptimization = 'optimizeSpeed';
  ctx.fillText(txt,x,y);
}
function drawBadge(txt,x,y,color){
  ctx.font='12px system-ui';
  const pad=6; const w=ctx.measureText(txt).width+pad*2;
  roundedRect(x,y-14,w,18,9,color); drawText(txt,x+pad,y+2,{font:'12px system-ui',color:'#fff'});
}

/* ---------- Hit testing registry ---------- */
let clickables = []; // items: {x,y,w,h,onClick,tag,data}

// Mouse events with coordinate conversion
canvas.addEventListener('mousemove', e=>{
  const coords = getCanvasCoordinates(e.clientX, e.clientY);
  canvas.style.cursor = hitAt(coords.x, coords.y) ? 'pointer' : 'default';
});

canvas.addEventListener('click', e=>{
  const coords = getCanvasCoordinates(e.clientX, e.clientY);
  const t = hitAt(coords.x, coords.y);
  if(t && t.onClick) t.onClick(t);
});

// Touch events for mobile with improved iOS/Android compatibility
let touchStartY = null;
let touchStartTime = 0;
let touchMoved = false;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  touchStartTime = Date.now();
  touchMoved = false;
  
  // Handle scroll gesture vs tap
  if(mode === MODES.MATCH && matchState && e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;
    
    // Improved touch detection for iOS
    const checkTap = () => {
      if(touchStartY !== null && !touchMoved) { // Still touching and hasn't moved = tap
        const touch = e.touches[0];
        if(touch) { // Make sure touch still exists
          const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
          const t = hitAt(coords.x, coords.y);
          if(t && t.onClick) {
            touchStartY = null; // Cancel scroll
            t.onClick(t);
          }
        }
      }
    };
    
    // Use requestAnimationFrame for better performance on iOS
    requestAnimationFrame(() => {
      setTimeout(checkTap, 50); // Reduced delay for better responsiveness
    });
  } else {
    // Immediate tap for other modes
    const touch = e.touches[0];
    if(touch) {
      const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
      const t = hitAt(coords.x, coords.y);
      if(t && t.onClick) t.onClick(t);
    }
  }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
  e.preventDefault(); // Prevent scrolling
  touchMoved = true; // Mark that touch has moved
  
  // Handle scrolling in match mode
  if(mode === MODES.MATCH && matchState && deckSizeMode === 'full' && touchStartY !== null && e.touches.length === 1) {
    const touchY = e.touches[0].clientY;
    const deltaY = (touchStartY - touchY) * 1.5; // Slightly reduced sensitivity for better control
    touchStartY = touchY;
    
    const ms = matchState;
    const viewH = ms.viewBottom - ms.viewTop;
    const maxScroll = Math.max(0, ms.contentH - viewH);
    ms.scrollY = Math.max(0, Math.min(maxScroll, ms.scrollY + deltaY));
    draw();
  }
}, {passive: false});

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  const touchDuration = Date.now() - touchStartTime;
  
  // Quick tap detection for better responsiveness
  if(!touchMoved && touchDuration < 200) {
    const touch = e.changedTouches[0];
    if(touch) {
      const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
      const t = hitAt(coords.x, coords.y);
      if(t && t.onClick) t.onClick(t);
    }
  }
  
  touchStartY = null;
  touchMoved = false;
}, {passive: false});

function hitAt(x,y){ for(const c of clickables){ if(x>=c.x && x<=c.x+c.w && y>=c.y && y<=c.y+c.h) return c; } return null; }
function resetClicks(){ clickables.length=0; }

/* ---------- Status text (top-right) ---------- */
function setStatus(s){ document.getElementById('status').textContent = s || ''; }

/****************************************************
 * MODE: MATCH RUSH (pairs) ‚Äî NOW WITH SCROLL
 ****************************************************/
function buildMatchDeck(){
  // Flatten all unit entries into a single deck (preserving unit name)
  return DATA.units.flatMap(u=>u.entries.map(e=>({...e, unit:u.name})));
}
function startMatchRound(){
  const deck = buildMatchDeck();
  let maxItems;
  
  if(deckSizeMode === 'auto') {
    // Adaptive deck size based on screen height - no scrolling needed
    const isMobile = scale < 0.7;
    const availableHeight = H - 140; // Header + footer space
    const boxH = isMobile ? 52 : 46;
    const gap = isMobile ? 10 : 14;
    const maxItemsOnScreen = Math.floor(availableHeight / (boxH + gap));
    maxItems = Math.max(5, Math.min(maxItemsOnScreen, deck.length)); // At least 5, max what fits
  } else {
    // Full deck mode - use all items, may require scrolling
    maxItems = Math.min(15, deck.length); // Cap at 15 to avoid performance issues
  }
  
  const picks = shuffle(deck.slice()).slice(0,maxItems);
  const left  = picks.map(p=>({txt:p.lv, key:p.lv, meta:p})); // match by LV string key
  const right = picks.map(p=>({txt:p.en, key:p.lv, meta:p})); // EN tiles carry same key
  shuffle(right);
  matchState = {
    left, right,
    selected:null,
    solved:new Set(),
    correct:0, total:maxItems,
    start:now(),
    lives: difficulty==='challenge'?3:Infinity,
    feedback:null,
    errors:0,
    detail:[],
    // SCROLL fields:
    scrollY: 0,            // current vertical scroll offset (px)
    contentH: 0,           // computed total list height (px)
    viewTop: 100,          // top Y for the scrollable list
    viewBottom: H-40,      // bottom Y limit for the list
  };
  draw();
}
function drawMatch(){
  clear(); resetClicks();

  // Header
  drawText("MATCH RUSH ‚Äî LV ‚Üí EN", 28, 40, {font:'bold 22px system-ui'});
  const ms = matchState; const elapsed=((now()-ms.start)/1000)|0;
  drawText(`Correct: ${ms.correct}/${ms.total}  |  Time: ${elapsed}s  |  ${ms.lives===Infinity?'‚àû':('‚ô•'.repeat(ms.lives))}`, W-20, 40, {align:'right',font:'16px system-ui',color:'#a8b3c7'});
  if(ms.feedback){ drawBadge(ms.feedback, 28, 58, ms.feedback.startsWith('Pareizi')? '#2f9e44' : '#8a2b2b'); }

  // Layout constants for tiles - RESPONSIVE
  const isMobile = scale < 0.7; // Detect smaller screens
  const Lx = isMobile ? 20 : 60;
  const boxW = isMobile ? Math.min(280, (W - 60) / 2) : 360;
  const boxH = isMobile ? 52 : 46;
  const gap = isMobile ? 10 : 14;
  const Rx = isMobile ? W - 20 - boxW : W - 60 - boxW;
  const top=ms.viewTop;                   // scrollable viewport top
  const viewH = ms.viewBottom - ms.viewTop; // viewport height

  // Column headers
  drawText("LV", Lx, top-22, {font:'bold 16px system-ui', color:'#9fb3ff'});
  drawText("EN", Rx, top-22, {font:'bold 16px system-ui', color:'#9fb3ff'});

  // Compute total content height once (both columns have same item count & heights)
  const totalItems = ms.left.length; // equals ms.right.length
  const contentH = totalItems*(boxH+gap) - gap; // last item has no trailing gap
  ms.contentH = contentH;
  const maxScroll = Math.max(0, contentH - viewH);
  if(ms.scrollY>maxScroll) ms.scrollY = maxScroll; // clamp if list shrank

  // Helper: draw one column (only visible items within viewport)
  function drawColumn(items, x, side){
    for(let i=0;i<items.length;i++){
      // y-position with virtual scroll applied
      const y = top + i*(boxH+gap) - ms.scrollY;
      // Skip if outside viewport to avoid painting and clickables we can't see
      if(y>ms.viewBottom || y+boxH<top) continue;

      const it = items[i];
      const solved = ms.solved.has(it.key);
      const sel = ms.selected && ms.selected.side===side && ms.selected.key===it.key;
      const color = solved? '#1e2530' : sel? '#344b7a' : '#222734';
      roundedRect(x,y,boxW,boxH,10,color, solved?'#3a4657':'#445066');
      drawText(it.txt, x+14, y+30, {font:'16px system-ui', color: solved? '#7d8aa0' : '#e9eef5'});

      // Register clickable only for visible items (perf + correctness)
      clickables.push({x,y,w:boxW,h:boxH, tag:`${side}:${i}`, data:it, onClick:()=>{
        if(solved) return;
        if(!ms.selected){ ms.selected={side, key:it.key}; draw(); return; }
        if(ms.selected.side===side){ ms.selected={side, key:it.key}; draw(); return; }
        // Compare keys cross-column
        const key = it.key;
        if(key===ms.selected.key){
          ms.solved.add(key);
          ms.correct++;
          ms.detail.push({type:'pair', lv: side==='L'?it.txt:ms.left.find(x=>x.key===key).txt,
                          en: side==='R'?it.txt:ms.right.find(x=>x.key===key).txt, ok:true});
          ms.feedback = "Pareizi ‚úì"; // keep LV feedback for learners
          ms.selected = null;
          confetti(y+boxH/2);
        } else {
          ms.errors++; ms.feedback = hintForMismatch(key, ms.selected.key);
          if(ms.lives!==Infinity){ ms.lives--; }
          ms.selected = null;
        }
        // End conditions
        if(ms.correct===ms.total){ endMatchRound(true); return; }
        if(ms.lives===0){ endMatchRound(false); return; }
        draw();
      }});
    }
  }

  // Draw visible tiles for both columns
  drawColumn(ms.left, Lx, 'L');
  drawColumn(ms.right, Rx, 'R');

  // Only draw scrollbar if content actually exceeds viewport
  if(maxScroll > 0){
    const trackX = W-20, trackW = 8; // Slightly wider and more accessible
    const trackY = top, trackH = viewH;
    
    // Track background
    roundedRect(trackX, trackY, trackW, trackH, 4, '#1a202a', '#2a3040');
    
    // Thumb size proportional to viewport/content ratio (min 30px for better touch)
    const thumbH = Math.max(30, (viewH * viewH) / contentH);
    const thumbY = trackY + (ms.scrollY / maxScroll) * (trackH - thumbH);
    roundedRect(trackX, thumbY, trackW, thumbH, 4, '#4a5675', '#5a6785');
    
    // Make scrollbar clickable for page up/down
    clickables.push({x:trackX,y:trackY,w:trackW,h:trackH,onClick:(t)=>{
      const clickY = t.y || trackY;
      const relativeY = clickY - trackY;
      const thumbCenter = (ms.scrollY / maxScroll) * (trackH - thumbH) + thumbH / 2;
      
      if(relativeY < thumbCenter - thumbH/2) {
        // Click above thumb - page up
        ms.scrollY = Math.max(0, ms.scrollY - viewH * 0.8);
      } else if(relativeY > thumbCenter + thumbH/2) {
        // Click below thumb - page down
        ms.scrollY = Math.min(maxScroll, ms.scrollY + viewH * 0.8);
      }
      draw();
    }});
    
    // Add scroll indicators if there's more content
    if(ms.scrollY > 0) {
      // Up arrow indicator
      drawText("‚Üë", W-16, top-5, {font:'12px system-ui', color:'#9fb3ff', align:'center'});
    }
    if(ms.scrollY < maxScroll) {
      // Down arrow indicator
      drawText("‚Üì", W-16, ms.viewBottom+15, {font:'12px system-ui', color:'#9fb3ff', align:'center'});
    }
  }

  if(showHelp) drawHelp();
}

// Pedagogical mismatch hinting (reflexive & prefix nudges)
function hintForMismatch(k1,k2){
  const all = DATA.units.flatMap(u=>u.entries.map(e=>e));
  const a = all.find(x=>x.lv===k1) || {}; const b = all.find(x=>x.lv===k2) || {};
  const ref = (e)=>(e.tags||[]).some(t=>t.includes('reflex'));
  if(ref(a)!==ref(b)) return "Padoms: -ties = refleksƒ´vs (pa≈°a stƒÅvoklis).";
  function pref(e){ const t=(e.tags||[]).find(t=>t.startsWith('prefix:')); return t? t.split(':')[1] : null; }
  const pa=pref(a), pb=pref(b);
  if(pa||pb){ const note = DATA.notes[`prefix:${pa||pb}`] || "Skaties priedƒìkƒºa nozƒ´mi."; return "Priedƒìklis: " + note; }
  return "Nesakrƒ´t. Pamƒìƒ£ini vƒìlreiz!";
}

function endMatchRound(success){
  const ms = matchState; const t = ((now()-ms.start)|0)/1000;
  results.push({mode:'MATCH', ts:new Date().toISOString(), correct:ms.correct, total:ms.total, time:t, details:ms.detail});
  setStatus(success?`Match: ${ms.correct}/${ms.total} ‚Ä¢ ${t}s`:`BeidzƒÅs dzƒ´vƒ´bas ‚Ä¢ ${ms.correct}/${ms.total}`);
  roundIndex++; // move forward and refresh
  startMatchRound();
}

// Tiny confetti burst for positive feedback
let bursts = [];
function confetti(y){ for(let i=0;i<14;i++){ bursts.push({x:W/2+(rng()*160-80), y:y+(rng()*20-10), vx:rng()*2-1, vy:-2-rng()*2, life:60}); } }

/****************************************************
 * MODE: PREFIX FORGE (unchanged mechanics)
 ****************************************************/
const ALL_PREFIXES = ["iz","pƒÅr","no","sa","ap","ie","pie","uz","at","aiz","pa"];
function startForgeRound(){
  const pool = DATA.forge.slice();
  const pick = pool[(roundIndex)%pool.length]; // deterministic but varied
  const opts = new Set([pick.correct]);
  while(opts.size<5) opts.add(choice(ALL_PREFIXES));
  const options = shuffle(Array.from(opts));
  forgeState = { base: pick.base, en: pick.en, correct: pick.correct, options, chosen:null, start:now(), correctCount:0, total:1, detail:[] };
  draw();
}
function drawForge(){
  clear(); resetClicks(); const fs = forgeState;
  drawText("PREFIX FORGE ‚Äî pievieno pareizo priedƒìkli", 28, 40, {font:'bold 22px system-ui'});
  drawText("EN: "+fs.en, 28, 78, {font:'16px system-ui', color:'#a8b3c7'});
  drawText(`_____${fs.base}`, 28, 120, {font:'bold 30px system-ui'});

  // Hint bar with prefix mini-buttons
  drawText("Priedƒìkƒºu ƒ´sƒÅs nozƒ´mes (tap for hint):", 28, 160, {font:'14px system-ui', color:'#9fb3ff'});
  let nx=28, ny=182; const hintRowMax = W-200;
  ALL_PREFIXES.forEach(p=>{
    const label = p+"-"; const w=ctx.measureText(label).width+20;
    roundedRect(nx,ny,w,32,10,'#22314a','#3f5675');
    drawText(label, nx+10, ny+22, {font:'16px system-ui'});
    const hint = DATA.notes['prefix:'+p] || '‚Äî';
    clickables.push({x:nx,y:ny,w:w,h:32,onClick:()=>setStatus(`Hint: ${p}- ‚Üí ${hint}`)});
    nx += w + 10; if(nx>hintRowMax){ nx=28; ny+=36; }
  });

  // Multiple-choice prefix buttons - RESPONSIVE
  const isMobile = scale < 0.7;
  const oy = ny + 50;
  const bw = isMobile ? Math.min(100, (W - 80) / 5) : 120;
  const bh = isMobile ? 48 : 54;
  let ox = 28;
  const gap = isMobile ? 8 : 12;
  fs.options.forEach(p=>{
    roundedRect(ox,oy,bw,bh,12,'#2a2f3a','#445066');
    drawText(p+'-', ox+16, oy+34, {font:'bold 22px system-ui'});
    clickables.push({x:ox,y:oy,w:bw,h:bh,onClick:()=>{
      const ok = p===fs.correct; const formed = p+fs.base;
      fs.detail.push({type:'forge', formed, ok, clue:fs.en});
      if(ok){ setStatus(`Pareizi: ${formed}`); confetti(oy+bh/2); }
      else { setStatus(`Nƒì: ${formed}. Pareizi: ${fs.correct+fs.base}`); }
      results.push({mode:'FORGE', ts:new Date().toISOString(), correct: ok?1:0, total:1, time:(((now()-fs.start)|0)/1000), details:[...fs.detail]});
      roundIndex++; startForgeRound();
    }});
    ox += bw + gap;
  });

  if(showHelp) drawHelp();
}

/* ---------- Help popup drawing ---------- */
function drawHelp(){
  const isMobile = scale < 0.7;
  const pad = isMobile ? 12 : 16;
  const w = isMobile ? Math.min(W - 40, 400) : 520;
  const h = isMobile ? Math.min(H - 40, 250) : 220;
  const x = W/2 - w/2;
  const y = H/2 - h/2;
  
  roundedRect(x,y,w,h,14,'#151821','#3a4252');
  drawText("Palƒ´dzƒ´ba", x+pad, y+28, {font:'bold 18px system-ui', color:'#9dd4ff'});
  
  const helpLines = HELP_TEXT.split('\n');
  const fontSize = isMobile ? 12 : 14;
  const lineHeight = isMobile ? 16 : 20;
  
  helpLines.forEach((line,i)=> {
    const yPos = y + 52 + i * lineHeight;
    if(yPos < y + h - 40) { // Don't draw outside help box
      drawText(line, x+pad, yPos, {font:`${fontSize}px system-ui`, color:'#d5dbe6'});
    }
  });
  
  // Close button
  const bw = isMobile ? 60 : 74;
  const bh = isMobile ? 32 : 28;
  const bx = x + w - bw - 16;
  const by = y + h - bh - 14;
  
  roundedRect(bx,by,bw,bh,10,'#334','#556');
  drawText("Aizvƒìrt", bx + (isMobile ? 8 : 12), by + (isMobile ? 22 : 20), {font:`${isMobile ? 12 : 14}px system-ui`});
  clickables.push({x:bx,y:by,w:bw,h:bh,onClick:()=>{ showHelp=false; draw(); }});
}

/* ---------- Main draw loop & confetti animation ---------- */
function draw(){
  if(mode===MODES.MATCH) drawMatch(); else drawForge();
  // Update confetti and animate if any particles are alive
  if(bursts.length){
    bursts.forEach(b=>{ b.x+=b.vx; b.y+=b.vy; b.vy+=0.06; b.life--; });
    bursts = bursts.filter(b=>b.life>0);
    ctx.save();
    bursts.forEach(b=>{ ctx.globalAlpha=Math.max(0,b.life/60); roundedRect(b.x,b.y,6,6,2,`hsl(${(b.x+b.y)%360}deg 60% 60%)`); });
    ctx.restore();
    requestAnimationFrame(draw); // keep animating while confetti exists
  }
}

/****************************************************
 * EXPORT RESULTS (CSV)
 ****************************************************/
function exportCSV(){
  const rows = [["mode","timestamp","correct","total","time_s","detail"].join(",")];
  for(const r of results){ const d = JSON.stringify(r.details).replaceAll('"','""'); rows.push([r.mode,r.ts,r.correct,r.total,r.time,`"${d}"`].join(",")); }
  const blob = new Blob([rows.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download="b1_game_results.csv"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/****************************************************
 * CONTROL BAR (top buttons)
 ****************************************************/
document.getElementById('mode-match').onclick = ()=>{ mode=MODES.MATCH; roundIndex=0; startMatchRound(); };
document.getElementById('mode-forge').onclick = ()=>{ mode=MODES.FORGE; roundIndex=0; startForgeRound(); };
document.getElementById('btn-practice').onclick = ()=>{ difficulty='practice'; setStatus("Practice re≈æƒ´ms"); };
document.getElementById('btn-challenge').onclick = ()=>{ difficulty='challenge'; setStatus("Challenge re≈æƒ´ms (Match = ‚ô•‚ô•‚ô•)"); };
document.getElementById('btn-prev').onclick = ()=>{ roundIndex=Math.max(0,roundIndex-1); mode===MODES.MATCH?startMatchRound():startForgeRound(); };
document.getElementById('btn-next').onclick = ()=>{ roundIndex++; mode===MODES.MATCH?startMatchRound():startForgeRound(); };
document.getElementById('btn-deck-size').onclick = ()=>{ 
  deckSizeMode = deckSizeMode === 'auto' ? 'full' : 'auto';
  const btn = document.getElementById('btn-deck-size');
  btn.textContent = deckSizeMode === 'auto' ? 'üìè' : 'üìú';
  btn.title = deckSizeMode === 'auto' ? 'Switch to full deck (scrollable)' : 'Switch to fit screen (no scroll)';
  setStatus(deckSizeMode === 'auto' ? 'Fit to screen mode' : 'Full deck mode (scrollable)');
  if(mode === MODES.MATCH) startMatchRound();
};
document.getElementById('btn-help').onclick = ()=>{ showHelp=!showHelp; draw(); };
document.getElementById('btn-export').onclick = exportCSV;

/****************************************************
 * KEYBOARD & INPUT ‚Äî includes SCROLLING for Match
 ****************************************************/
window.addEventListener('keydown', (e)=>{
  if(e.key==='1'){ document.getElementById('mode-match').click(); }
  if(e.key==='2'){ document.getElementById('mode-forge').click(); }
  if(e.key==='h' || e.key==='H'){ document.getElementById('btn-help').click(); }
  if(e.key==='r' || e.key==='R'){ mode===MODES.MATCH?startMatchRound():startForgeRound(); }
  if(e.key==='d' || e.key==='D'){ document.getElementById('btn-deck-size').click(); }

  // Scroll keys active only in MATCH mode when content exceeds viewport
  if(mode===MODES.MATCH && matchState && deckSizeMode === 'full'){
    const ms = matchState; const viewH = ms.viewBottom - ms.viewTop; const maxScroll = Math.max(0, ms.contentH - viewH);
    if(maxScroll > 0) { // Only allow scrolling if content actually overflows
      const step = 30; const page = Math.max(120, viewH - 80);
      if(e.key==='ArrowDown'){ ms.scrollY = Math.min(maxScroll, ms.scrollY + step); draw(); }
      if(e.key==='ArrowUp'){   ms.scrollY = Math.max(0,         ms.scrollY - step); draw(); }
      if(e.key==='PageDown'){  ms.scrollY = Math.min(maxScroll, ms.scrollY + page); draw(); }
      if(e.key==='PageUp'){    ms.scrollY = Math.max(0,         ms.scrollY - page); draw(); }
      if(e.key==='End'){       ms.scrollY = maxScroll; draw(); }
      if(e.key==='Home'){      ms.scrollY = 0;         draw(); }
    }
  }
});

// Mouse wheel scrolling for MATCH mode (only in full deck mode)
canvas.addEventListener('wheel', (e)=>{
  if(mode!==MODES.MATCH || !matchState || deckSizeMode !== 'full') return;
  const ms = matchState; const viewH = ms.viewBottom - ms.viewTop; const maxScroll = Math.max(0, ms.contentH - viewH);
  if(maxScroll === 0) return; // No scrolling needed
  e.preventDefault(); // keep page from scrolling; we scroll the canvas content instead
  const delta = Math.sign(e.deltaY) * 40; // fixed step for predictability
  ms.scrollY = Math.max(0, Math.min(maxScroll, ms.scrollY + delta));
  draw();
}, {passive:false});

// Window resize handler for responsive canvas
window.addEventListener('resize', () => {
  updateCanvasScale();
  if(mode === MODES.MATCH && matchState) {
    draw(); // Redraw to adjust layout
  }
});

/* ---------- INIT ---------- */
setStatus("Gatavs. Izvƒìlies re≈æƒ´mu.");

// Show loading state
const loadingOverlay = document.getElementById('loading');
const canvasElement = document.getElementById('canvas');
loadingOverlay.classList.add('visible');
canvasElement.classList.add('loading');

// Ensure canvas is properly scaled before first draw
function initializeGame() {
  updateCanvasScale();
  startMatchRound();
  
  // Hide loading state
  loadingOverlay.classList.remove('visible');
  canvasElement.classList.remove('loading');
}

// Initialize when DOM is ready and fonts are loaded
function startInit() {
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => {
      setTimeout(initializeGame, 50); // Small delay to ensure everything is ready
    });
  } else {
    setTimeout(initializeGame, 150);
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', startInit);
} else {
  startInit();
}
</script>
</body>
</html>
