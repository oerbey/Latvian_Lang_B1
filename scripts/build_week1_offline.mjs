import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';

const ROOT = path.resolve(import.meta.dirname, '..');
const I18N_DIR = path.join(ROOT, 'i18n');
const DATA_DIR = path.join(ROOT, 'data');
const ENDINGS_DIR = path.join(DATA_DIR, 'endings-builder');

async function loadJson(filePath) {
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

async function writeJs(filePath, header, assignment, payload) {
  const body = JSON.stringify(payload, null, 2);
  const content = `${header}\n${assignment} ${body});\n`;
  await writeFile(filePath, content, 'utf8');
  console.log(`Wrote ${path.relative(ROOT, filePath)}`);
}

async function buildI18nBundle() {
  const bundle = {};
  const files = ['lv.json', 'en.json', 'ru.json'];
  for (const file of files) {
    const filePath = path.join(I18N_DIR, file);
    try {
      bundle[path.basename(file, '.json')] = await loadJson(filePath);
    } catch {
      // ignore missing files
    }
  }
  return bundle;
}

async function buildVocabBundle() {
  const bundle = {};
  const targets = ['lv-en', 'lv-ru'];
  for (const target of targets) {
    const base = path.join(DATA_DIR, target);
    try {
      const index = await loadJson(path.join(base, 'units.json'));
      const forge = await loadJson(path.join(base, 'forge.json'));
      const unitsMap = {};
      for (const entry of index.units ?? []) {
        const filePath = entry?.file;
        if (!filePath) continue;
        const source = path.join(base, filePath);
        try {
          unitsMap[filePath] = await loadJson(source);
        } catch {
          // skip missing unit files
        }
      }
      bundle[target] = { index, forge, units: unitsMap };
    } catch {
      // skip missing targets
    }
  }
  return bundle;
}

async function buildEndingsPayload() {
  const tables = await loadJson(path.join(ENDINGS_DIR, 'tables.json'));
  const items = await loadJson(path.join(ENDINGS_DIR, 'items.json'));
  return { tables, items };
}

async function main() {
  const [i18nBundle, vocabBundle, endingsPayload] = await Promise.all([
    buildI18nBundle(),
    buildVocabBundle(),
    buildEndingsPayload(),
  ]);

  await writeJs(
    path.join(I18N_DIR, 'offline.js'),
    '// Auto-generated by scripts/build_week1_offline.mjs. Do not edit manually.',
    'window.__LL_I18N__ = Object.assign({}, window.__LL_I18N__ || {},',
    i18nBundle,
  );

  await writeJs(
    path.join(DATA_DIR, 'week1.offline.js'),
    '// Auto-generated by scripts/build_week1_offline.mjs. Do not edit manually.',
    'window.__WEEK1_VOCAB__ = Object.assign({}, window.__WEEK1_VOCAB__ || {},',
    vocabBundle,
  );

  const endingsPath = path.join(ENDINGS_DIR, 'offline.js');
  const endingsContent = [
    '// Auto-generated by scripts/build_week1_offline.mjs. Do not edit manually.',
    `window.__ENDINGS_DATA__ = window.__ENDINGS_DATA__ || ${JSON.stringify(endingsPayload.tables, null, 2)};`,
    `window.__ENDINGS_ITEMS__ = window.__ENDINGS_ITEMS__ || ${JSON.stringify(endingsPayload.items, null, 2)};`,
    '',
  ].join('\n');
  await writeFile(endingsPath, endingsContent, 'utf8');
  console.log(`Wrote ${path.relative(ROOT, endingsPath)}`);
}

main().catch((err) => {
  console.error('Failed to build offline bundles', err);
  process.exit(1);
});
