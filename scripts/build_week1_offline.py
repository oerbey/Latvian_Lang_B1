#!/usr/bin/env python3
"""
Generate offline fallback bundles for Week 1 games and Endings Builder.

Outputs:
- i18n/offline.js        -> embedded translations for LV/EN/RU
- data/week1.offline.js  -> embedded vocabulary decks (lv-en, lv-ru)
- src/data/endings.offline.js -> embedded declension tables/items

Run: python3 scripts/build_week1_offline.py
"""

from __future__ import annotations

import json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
I18N_DIR = ROOT / "i18n"
DATA_DIR = ROOT / "data"
ENDINGS_DIR = ROOT / "src" / "data"


def load_json(path: Path):
    return json.loads(path.read_text(encoding="utf-8"))


def write_js(path: Path, header: str, assignment: str, payload: dict):
    path.parent.mkdir(parents=True, exist_ok=True)
    body = json.dumps(payload, ensure_ascii=False, indent=2)
    content = f"{header}\n{assignment} {body});\n"
    path.write_text(content, encoding="utf-8")
    print(f"Wrote {path.relative_to(ROOT)}")


def build_i18n_bundle() -> dict:
    bundle = {}
    for lang_file in ("lv.json", "en.json", "ru.json"):
        path = I18N_DIR / lang_file
        if path.exists():
            lang = path.stem
            bundle[lang] = load_json(path)
    return bundle


def build_vocab_bundle() -> dict:
    bundle = {}
    for target in ("lv-en", "lv-ru"):
        base = DATA_DIR / target
        if not base.exists():
            continue
        index = load_json(base / "units.json")
        forge = load_json(base / "forge.json")
        units_map = {}
        for entry in index.get("units", []):
            file_path = entry.get("file")
            if not file_path:
                continue
            source = base / file_path
            if not source.exists():
                continue
            units_map[file_path] = load_json(source)
        bundle[target] = {
            "index": index,
            "forge": forge,
            "units": units_map,
        }
    return bundle


def main():
    i18n_bundle = build_i18n_bundle()
    vocab_bundle = build_vocab_bundle()
    endings_data = {
        "tables": load_json(ENDINGS_DIR / "endings.json"),
        "items": load_json(ENDINGS_DIR / "endings-items.json"),
    }

    write_js(
        ROOT / "i18n" / "offline.js",
        "// Auto-generated by scripts/build_week1_offline.py. Do not edit manually.",
        "window.__LL_I18N__ = Object.assign({}, window.__LL_I18N__ || {},",
        i18n_bundle,
    )

    write_js(
        ROOT / "data" / "week1.offline.js",
        "// Auto-generated by scripts/build_week1_offline.py. Do not edit manually.",
        "window.__WEEK1_VOCAB__ = Object.assign({}, window.__WEEK1_VOCAB__ || {},",
        vocab_bundle,
    )

    endings_path = ENDINGS_DIR / "endings.offline.js"
    endings_payload = (
        "// Auto-generated by scripts/build_week1_offline.py. Do not edit manually.\n"
        f"window.__ENDINGS_DATA__ = window.__ENDINGS_DATA__ || {json.dumps(endings_data['tables'], ensure_ascii=False, indent=2)};\n"
        f"window.__ENDINGS_ITEMS__ = window.__ENDINGS_ITEMS__ || {json.dumps(endings_data['items'], ensure_ascii=False, indent=2)};\n"
    )
    endings_path.write_text(endings_payload, encoding="utf-8")
    print(f"Wrote {endings_path.relative_to(ROOT)}")


if __name__ == "__main__":
    main()
